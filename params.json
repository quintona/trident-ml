{"name":"Trident-ml","tagline":"Trident-ML : A distributed realtime online machine learning library","body":"Trident-ML is a realtime online machine learning library. It allows you to build real time predictive features using scalable online algorihms.\r\nThis library is built on top of [Storm](https://github.com/nathanmarz/storm), a distributed stream processing framework which runs on a cluster of machines and supports horizontal scaling.\r\nThe packaged algorithms are designed to fit into limited memory and processing time but they don't work in a distributed way.\r\n\r\nTrident-ML currently supports : \r\n* Linear classification (Perceptron, Passive-Aggresive, Winnow, AROW)\r\n* Linear regression (Perceptron, Passive-Aggresive)\r\n* Clustering (KMeans)\r\n* Feature scaling (standardization, normalization)\r\n* Text feature extraction\r\n* Stream statistics (mean, variance)\r\n\r\n# API Overview\r\n\r\nTrident-ML is based on [Trident](https://github.com/nathanmarz/storm/wiki/Trident-tutorial), a high-level abstraction for doing realtime computing.\r\nIf you're familiar with high level batch processing tools like Pig or Cascading, the concepts of Trident will be very familiar.\r\n\r\n## Create instances\r\n\r\nTrident-ML process unbounded streams of data implemented by an infinite collection of [Instance](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/core/Instance.java) or [TextInstance](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/core/TextInstance.java).\r\nCreating instances is the first step to build a prediction tools.\r\nTrident-ML offers [Trident functions](https://github.com/nathanmarz/storm/wiki/Trident-API-Overview#functions) to convert Trident tuples to instances :\r\n\r\n* Use [InstanceCreator](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/preprocessing/InstanceCreator.java) to create [Instance](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/core/Instance.java)\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\ntoppology\r\n  // Emit tuples with 2 random features (named x0 and x1) and an associated boolean label (named label)\r\n  .newStream(\"randomFeatures\", new RandomFeaturesSpout())\r\n  \r\n  // Transform trident tuple to instance\r\n  .each(new Fields(\"label\", \"x0\", \"x1\"), new InstanceCreator<Boolean>(), new Fields(\"instance\"));\r\n```\r\n\r\n* Use [TextInstanceCreator](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/preprocessing/TextInstanceCreator.java) to create [TextInstance](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/core/TextInstance.java)\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\ntoppology\r\n  // Emit tuples containing text and associated label (topic)\r\n  .newStream(\"reuters\", new ReutersBatchSpout())\r\n\r\n  // Convert trident tuple to text instance\r\n  .each(new Fields(\"label\", \"text\"), new TextInstanceCreator<Integer>(), new Fields(\"instance\"));\r\n```\r\n\r\n## Supervised classification\r\nTrident-ML includes differents algorithms to do supervised classification : \r\n* [PerceptronClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/PerceptronClassifier.java)\r\nimplements a binary classifier based on an averaged kernel-based perceptron.\r\n* [WinnowClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/WinnowClassifier.java)\r\nimplements [Winnow algorithm](http://link.springer.com/content/pdf/10.1007%2FBF00116827.pdf).\r\nIt scales well to high-dimensional data and performs better than a perceptron when many dimensions are irrelevant. \r\n* [BWinnowClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/BWinnowClassifier.java)\r\n is an implementation of the [Balanced Winnow algorithm](http://link.springer.com/content/pdf/10.1007%2FBF00116827.pdf) \r\nan extension of the original Winnow algorithm.\r\n* [AROWClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/AROWClassifier.java)\r\nis an simple and efficient implementation of [Adaptive Regularization of Weights](http://books.nips.cc/papers/files/nips22/NIPS2009_0611.pdf).\r\nIt combines several useful properties : large margin training, confidence weighting, and the capacity to handle non-separable data.\r\n* [PAClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/PAClassifier.java)\r\nimplements the [Passive-Aggresive binary classifier](http://eprints.pascal-network.org/archive/00002147/01/CrammerDeKeShSi06.pdf)\r\na margin based learning algorithm.\r\n* [MultiClassPAClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/MultiClassPAClassifier.java)\r\na variant of the Passive-Aggresive performing one-vs-all multiclass classification.\r\n\r\nTheses classifiers learn from a datastream of labeled [Instance](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/core/Instance.java)\r\nusing a [ClassifierUpdater](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/ClassifierUpdater.java).\r\nAnother datastream of unlabeled instance can be classified with a [ClassifyQuery](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/classification/ClassifyQuery.java).\r\n\r\nThe following example learn a NAND function and classify instances comming from a DRPC stream.\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\n// Create perceptron state from labeled instances stream\r\nTridentState perceptronModel = toppology\r\n  // Emit tuple with a labeled instance of enhanced NAND features\r\n  // i.e. : {label=true, features=[1.0 0.0 1.0]} or {label=false, features=[1.0 1.0 1.0]}  \r\n  .newStream(\"nandsamples\", new NANDSpout())\r\n\t\t\t\t\r\n  // Update perceptron\r\n  .partitionPersist(new MemoryMapState.Factory(), new Fields(\"instance\"), new ClassifierUpdater<Boolean>(\"perceptron\", new PerceptronClassifier()));\r\n\r\n// Classify instance from a DRPC stream\r\ntoppology.newDRPCStream(\"predict\", localDRPC)\r\n  // Transform DRPC ARGS to unlabeled instance\r\n  .each(new Fields(\"args\"), new DRPCArgsToInstance(), new Fields(\"instance\"))\r\n\r\n  // Classify instance using perceptron state\r\n  .stateQuery(perceptronModel, new Fields(\"instance\"), new ClassifyQuery<Boolean>(\"perceptron\"), new Fields(\"prediction\"));\r\n```\t\t\t\t\r\n\r\nTrident-ML provides the [KLDClassifier](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/nlp/KLDClassifier.java)\r\nwhich implements a [text classifier using the Kullback-Leibler Distance](http://lvk.cs.msu.su/~bruzz/articles/classification/Using%20Kullback-Leibler%20Distance%20for%20Text%20Categorization.pdf).\r\n\r\nHere's the code to build a news classifier using Reuters dataset :\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\n// Create KLD classifier state from labeled instances stream\r\nTridentState classifierState = toppology\r\n  // Emit tuples containing text and associated label (topic)\r\n  .newStream(\"reuters\", new ReutersBatchSpout())\r\n\r\n  // Convert trident tuple to text instance\r\n  .each(new Fields(\"label\", \"text\"), new TextInstanceCreator<Integer>(), new Fields(\"instance\"))\r\n  \r\n  // Update classifier\r\n  .partitionPersist(new MemoryMapState.Factory(), new Fields(\"instance\"), new TextClassifierUpdater(\"newsClassifier\", new KLDClassifier(9)));\r\n\r\n// Classification stream\r\ntoppology.newDRPCStream(\"classify\", localDRPC)\r\n\r\n  // Convert DRPC args to text instance\r\n  .each(new Fields(\"args\"), new TextInstanceCreator<Integer>(false), new Fields(\"instance\"))\r\n\r\n  // Query classifier with text instance\r\n  .stateQuery(classifierState, new Fields(\"instance\"), new ClassifyTextQuery(\"newsClassifier\"), new Fields(\"prediction\"));\r\n```\r\n\r\n## Unsupervised classification\r\n[KMeans](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/clustering/KMeans.java)\r\nis an implementation of the well known [k-means algorithm](http://en.wikipedia.org/wiki/K-means_clustering)\r\nwhich partitions instances into clusters.\r\n\r\nUse a [ClusterUpdater](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/clustering/ClusterUpdater.java)\r\nor a [ClusterQuery](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/clustering/ClusterQuery.java)\r\nto respectively udpate clusters or query the clusterer :\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\n// Training stream\r\nTridentState kmeansState = toppology\r\n  // Emit tuples with a instance containing an integer as label and 3 double features named (x0, x1 and x2)\r\n  .newStream(\"samples\", new RandomFeaturesForClusteringSpout())\r\n\r\n  // Convert trident tuple to instance\r\n  .each(new Fields(\"label\", \"x0\", \"x1\", \"x2\"), new InstanceCreator<Integer>(), new Fields(\"instance\"))\r\n\r\n  // Update a 3 classes kmeans\r\n  .partitionPersist(new MemoryMapState.Factory(), new Fields(\"instance\"), new ClusterUpdater(\"kmeans\", new KMeans(3)));\r\n\r\n// Cluster stream\r\ntoppology.newDRPCStream(\"predict\", localDRPC)\r\n  // Convert DRPC args to instance\r\n  .each(new Fields(\"args\"), new DRPCArgsToInstance(), new Fields(\"instance\"))\r\n\r\n  // Query kmeans to classify instance\r\n  .stateQuery(kmeansState, new Fields(\"instance\"), new ClusterQuery(\"kmeans\"), new Fields(\"prediction\"));\r\n```\r\n\r\n## Stream statistics\r\nStream statistics such as mean, standard deviation and count can be easily computed using Trident-ML.\r\nTheses statistics are stored in a [StreamStatistics](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/stats/StreamStatistics.java) object.\r\nStatistics update and query are performed respectively using a [StreamStatisticsUpdater](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/stats/StreamStatisticsUpdater.java) and a [StreamStatisticsQuery](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/stats/StreamStatisticsQuery.java) :\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\n// Update stream statistics\r\nTridentState streamStatisticsState = toppology\r\n  // emit tuples with random features\r\n  .newStream(\"randomFeatures\", new RandomFeaturesSpout())\r\n\r\n  // Transform trident tuple to instance\r\n  .each(new Fields(\"x0\", \"x1\"), new InstanceCreator(), new Fields(\"instance\"))\r\n\r\n  // Update stream statistics\r\n  .partitionPersist(new MemoryMapState.Factory(), new Fields(\"instance\"), new StreamStatisticsUpdater(\"randomFeaturesStream\", StreamStatistics.fixed()));\r\n\r\n// Query stream statistics (with DRPC)\r\ntoppology.newDRPCStream(\"queryStats\", localDRPC)\r\n  // Query stream statistics\r\n  .stateQuery(streamStatisticsState, new StreamStatisticsQuery(\"randomFeaturesStream\"), new Fields(\"streamStats\"));\r\n\r\n```\r\nNote that Trident-ML can suppport concept drift in a sliding window manner.\r\nUse StreamStatistics#adaptive(maxSize) instead of StreamStatistics#fixed() to construct StreamStatistics implementation with a maxSize length window.\r\n\r\n\r\n## Preprocessing data\r\nData preprocessing is an important step in the data mining process. \r\nTrident-ML provides Trident functions to transform raw features into a representation that is more suitable for machine learning algorithms.\r\n\r\n* [Normalizer](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/preprocessing/Normalizer.java) scales individual instances to have unit norm. \r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\ntoppology\r\n  // Emit tuples with 2 random features (named x0 and x1) and an associated boolean label (named label)\r\n  .newStream(\"randomFeatures\", new RandomFeaturesSpout())\r\n\r\n  // Convert trident tuple to instance\r\n  .each(new Fields(\"label\", \"x0\", \"x1\"), new InstanceCreator<Boolean>(), new Fields(\"instance\"))\r\n\t  \r\n  // Scales features to unit norm\r\n  .each(new Fields(\"instance\"), new Normalizer(), new Fields(\"scaledInstance\"));\r\n```\r\n\r\n* [StandardScaler](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/preprocessing/StandardScaler.java) transform raw features to standard normally distributed data (Gaussian with zero mean and unit variance). It uses [Stream Statistics](https://github.com/pmerienne/trident-ml/blob/master/src/main/java/storm/trident/ml/stats/StreamStatistics.java) to remove mean and scale to variance.\r\n\r\n```java\r\nTridentTopology toppology = new TridentTopology();\r\n\r\ntoppology\r\n  // Emit tuples with 2 random features (named x0 and x1) and an associated boolean label (named label)\r\n  .newStream(\"randomFeatures\", new RandomFeaturesSpout())\r\n\r\n  // Convert trident tuple to instance\r\n  .each(new Fields(\"label\", \"x0\", \"x1\"), new InstanceCreator<Boolean>(), new Fields(\"instance\"))\r\n\t\t  \r\n  // Update stream statistics\r\n  .partitionPersist(new MemoryMapState.Factory(), new Fields(\"instance\"), new StreamStatisticsUpdater(\"streamStats\", new StreamStatistics()), new Fields(\"instance\", \"streamStats\")).newValuesStream()\r\n\r\n  // Standardize stream using original stream statistics\r\n  .each(new Fields(\"instance\", \"streamStats\"), new StandardScaler(), new Fields(\"scaledInstance\"));\r\n```\r\n\r\n# Upcoming features\r\n* Noise adaptive filter (LMS, Wiener, Kalman, ...)\r\n* Distributed algorithms\r\n* Change detection\r\n","google":"UA-40405535-1","note":"Don't delete this file! It's used internally to help with page regeneration."}